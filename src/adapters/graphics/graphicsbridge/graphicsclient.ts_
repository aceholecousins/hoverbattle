
import {Graphics} from "domain/graphics/graphics"
import {SceneNodeConfig} from "domain/graphics/scenenode"
import {SceneNodeHandle} from "./scenenodehandle"
import {AssetConfig} from "domain/graphics/asset"
import {AssetHandle} from "./assethandle"
import {WorkerBridge, RemoteProc} from "worker/workerbridge"
import {UpdateBundler} from "./updatebundler"
import {Kind} from "utils"

export class GraphicsClient implements Graphics{
	private modelCounter = 0
	private sceneNodeCounter = 0

	private _loadAssetOnServer:RemoteProc
	private _addObjectOnServer:RemoteProc
	private _syncObjectsOnServer:RemoteProc
	private _updateBundler:UpdateBundler

	constructor(bridge:WorkerBridge){
		this._loadAssetOnServer = bridge.createCaller("gfx.loadAsset")
		this._addObjectOnServer = bridge.createCaller("gfx.addObject")
		this._syncObjectsOnServer = bridge.createCaller("gfx.syncObjects")
		this._updateBundler = new UpdateBundler()
	}

	loadAsset<K extends Kind>(
		config:AssetConfig<K>,
		onLoaded?:()=>void,
		onError?:(err:ErrorEvent)=>void
	):AssetHandle<K>{
		const index = this.modelCounter++
		this._loadAssetOnServer({index, config:config})
		let result = {kind:config.kind, index, file:config.file}
		return result
	}

	addObject<K extends Kind>(config:SceneNodeConfig<K>):SceneNodeHandle<K>{
		const index = this.sceneNodeCounter++
		this._addObjectOnServer({index, config})
		let result = new SceneNodeHandle<K>(index, this._updateBundler, config)
		return result
	}
	
	update(){
		this._syncObjectsOnServer(this._updateBundler.popUpdates())
	}
}

