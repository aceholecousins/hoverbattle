
import {vec3, quat} from "gl-matrix"
import {Kind} from "utils"
import {SceneNode, SceneNodeConfig} from "domain/graphics/scenenode"
import {NodeMessageBundler} from "./nodemessagebundler"

export class SceneNodeHandle<K extends Kind> implements SceneNode<K>{
	kind:K
	index:number
	protected bundler:NodeMessageBundler

	constructor(
		index:number,
		kind:K,
		bundler:NodeMessageBundler
	){
		this.index = index
		this.kind = kind
		this.bundler = bundler
	}

	set position(p:vec3){
		this.bundler.addUpdate(this.index, {position:p})
	}

	set orientation(q:quat){
		this.bundler.addUpdate(this.index, {orientation:q})
	}

	set scaling(s:vec3){
		this.bundler.addUpdate(this.index, {scaling:s})
	}

	remove(){
		this.bundler.addUpdate(this.index, {remove:[]})
	}
}

type SceneNodeClass<K extends Kind> = new(
	index:number,
	kind:K,
	bundler:NodeMessageBundler
) => SceneNodeHandle<K>

let sceneNodeIndexCounter = 0

export class SceneNodeHandleFactory{
	bundler:NodeMessageBundler

	constructor(bundler:NodeMessageBundler){
		this.bundler = bundler
	}

	protected createHandle<K extends Kind, T extends SceneNodeClass<K>>(
		Product:T,
		config:SceneNodeConfig<K>
	){
		const index = sceneNodeIndexCounter++
		this.bundler.addCreation(index, config)
		// already while I am typing this code, I can hear the imaginary Dani in my head
		// be like "Uh, oh, the way you use classes as first class citizens confuses me,
		// please change everything so people like me understand it right away."
		return new Product(index, config.kind, this.bundler) as InstanceType<T>	
	}
}