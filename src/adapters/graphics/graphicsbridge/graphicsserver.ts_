
import {Kind, Registry} from "utils"
import {Graphics} from "domain/graphics/graphics"
import {Asset} from "domain/graphics/asset"
import {SceneNode, SceneNodeConfig} from "domain/graphics/scenenode"
import {SceneNodeMessage} from "./client/nodemessagebundler"
import {WorkerBridge} from "worker/workerbridge"

import {forwardCameraCreation} from "./server/cameraforwarder"
import {forwardLightCreation} from "./server/lightforwarder"
import {forwardMeshCreation} from "./server/meshforwarder"

// TODO: define types and id strings (like "gfx.loadAsset") at a single place for typesafe exchange

export class GraphicsServer{

	private assets:Asset<any>[] = []
	private nodes:SceneNode<any>[] = []
	private engine:Graphics
	private forwardCreation:{[kind: string]: (config:SceneNodeConfig<any>)=>void}

	constructor(bridge:WorkerBridge, engine:Graphics){
		this.engine = engine
		bridge.registerProcedure(this.loadAsset, "gfx.loadAsset")
		bridge.registerProcedure(this.updateNodes, "gfx.updateNodes")

		this.forwardCreation = {
			...forwardCameraCreation(this.engine),
			...forwardLightCreation(this.engine),
			...forwardMeshCreation(this.engine)
		}
	}

	loadAsset({kind, index, file}:{kind:Kind, index:number, file:string}){
		switch(kind){
			case "model":
				this.assets[index] = this.engine.model.load(file, ()=>{}, ()=>{}) // TODO onload and error forwarding
				break
		}
	}

	updateNodes({time, messages}:{time:number, messages:SceneNodeMessage[]}){
		for(const i in messages){
			const message = messages[i]

			if("createWithConfig" in message){
				let config = message.createWithConfig
				this.forwardCreation[config.kind](config)
			}

			if("removeMe" in message && message.removeMe){
				this.nodes[i].remove()
				delete(this.nodes[i])
			}
			else{
				Object.assign(this.nodes[i])
			}
		}
	}
}
